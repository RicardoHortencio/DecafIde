		/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

group TAC;

Main(structDec, field, mainMethod, method, arrayFieldInit) ::= <<
	.assembly extern mscorlib
	{}

	.assembly MyApp
	{}

	.class private auto ansi beforefieldinit Program
	{
		<structDec; separator="\n">
		<field; separator="\n">
		<mainMethod; separator="\n">
		<method; separator="\n">

		.method public hidebysig specialname rtspecialname
		instance void  .ctor() cil managed
		{
		  .maxstack  8
		  <arrayFieldInit; separator="\n">
		  ldarg.0
		  call       instance void [mscorlib]System.Object::.ctor()
		  ret
		}
	}
>>

ArrayFieldInit(name, size, type) ::= <<
  ldarg.0
  ldc.i4.s   <size>
  newarr     <type>
  stfld      <name>
>>

StructDec(name, structDec, field) ::= <<
.public static class <name>
  {
	<structDec; separator="\n">
	<field; separator="\n">
  } // end of class <name>
>>

Field(typeName, id, isArray) ::= <<
	.field public <typeName><if(isArray)>[]<endif> <id>program
>>

Method(typeName, id, parameters, stackSize, localVar, statements) ::= <<
.method public <typeName> '<id>'(<parameters; separator=", ">)
  {
	.maxstack <stackSize>
	.locals init (
		<localVar; separator=", ">
	)
	<statements; separator="\n">
  } // end of method Program::'<id>'
  >>

MainMethod(stackSize, localVar, statements) ::= <<
	.method hidebysig private static void
	Main(string[] y) cil managed
	{
		  .entrypoint
		  .maxstack <stackSize>
		  .locals (
			  <localVar; separator=", ">
		  )
		  <statements; separator="\n">

	} // end of method Program::Main
>>

TypeName(typeName, isStruct) ::= <<
	<if(isStruct)>valuetype<endif> <typeName>
>>

Parameter(typeName, id) ::=<<
	<typeName> <id>
>>

LocalVar(typeName, id, isArray) ::= <<
	<typeName><if(isArray)>[]<endif> <id>
>>

BinaryOp(expressionOne, expressionTwo, op, requireNot) ::= <<
	<expressionOne>
	<expressionTwo>
	<op>
	<if(requireNot)>not<endif>
>>

UnaryOp(expression, op) ::= <<
	<expression>
	<op>
>>

Assignment(loadLocation, expression, storeLocation)  ::= <<
	<loadLocation>
	<expression>
	<storeLocation>
>>

IfCmd(expression, code, Lzero)  ::= <<
	<expression>
	brfalse.s <LZero>
	<code; separator="\n">
<Lzero>:
>>

IfElse(condition, ifcode, elsecode, LZero, LOne)  ::= <<
	<condition>
	brfalse.s <LZero>
	<ifcode; separator="\n">
	br.s <LOne>
<LZero>:
	<elseCode; separator="\n">
<LOne>:
>>

While(condition, code, LZero, LOne)  ::= <<
<LZero>:
	<condition>
	brfalse.s <LOne>
	<statements; separator="\n">
	br.s <LZero>
<LOne>:
>>

Return(expression) ::= <<
	<expression; separator =";">
	ret
>>

MethodCall(methodType, methodName, parameterType, expression) ::= <<
	<expression; separator =";">
	call instance <methodType> Program::'<methodName>'(<parameterType; separator =",">)
>>

VarDecl(id, type) ::= <<
	Load<type> <id>
>>

VarStructDecl(id, type) ::= <<
	LoadStruct <id>
	LoadStructName <type>
>>

ArrayDecl(varloading, position) ::= <<
{
	<varloading>
	LoadPosition <position>
}
>>