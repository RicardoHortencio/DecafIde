		/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

group TAC;

Main(structDec, field, mainMethod, method, arrayFieldInit) ::= <<
	.assembly extern mscorlib
	{}

	.assembly MyApp
	{}

	.class private auto ansi beforefieldinit Program
	   extends [mscorlib]System.Object
	{
		<structDec; separator="\n">
		<field; separator="\n">
		<mainMethod; separator="\n">
		<method; separator="\n">

		.method public hidebysig specialname rtspecialname
		instance void  .ctor() cil managed
		{
		  .maxstack  32
		  <arrayFieldInit; separator="\n">
		  ldarg.0
		  call       instance void [mscorlib]System.Object::.ctor()
		  ret
		}
	}
>>

ArrayFieldInit(name, size, type) ::= <<
  ldarg.0
  ldc.i4.s   <size>
  newarr     <type>
  stfld      <name>
>>

ArrayInit(name, size, type) ::= <<
  ldarg.0
  ldc.i4.s   <size>
  newarr     <type>
  stloc.s  <name>
>>

StructDec(name, structDec, field) ::= <<
.class sequential ansi sealed nested public beforefieldinit <name>
  extends [mscorlib]System.ValueType
  {
	<structDec; separator="\n">
	<field; separator="\n">
  } // end of class <name>
>>

Field(typeName, id, isArray) ::= <<
	.field public <typeName><if(isArray)>[]<endif> <id>program
>>

MethodSignature(typeName, id, parameters, stackSize, localVar, statements) ::= <<
.method public hidebysig instance <typeName> '<id>'(<parameters; separator=", ">) cil managed
>>

Method(typeName, id, parameters, stackSize, localVar, statements) ::= <<
  <methodSignature>
  {
	.maxstack 32
	.locals init (
		<localVar; separator=", ">
	)
	<arrayInit; separator="\n">
	<statements; separator="\n">
  } // end of method Program::'<id>'
  >>

BaseBlock(statements) ::= <<
	<statements; separator="\n">
>>

MainMethod(stackSize, localVar, statements) ::= <<
	.method hidebysig private static void
	Main(string[] y) cil managed
	{
		  .entrypoint
		  .maxstack 32
		  .locals (
			  <localVar; separator=", ">
		  )
		  <arrayInit; separator="\n">
		  <statements; separator="\n">

	} // end of method Program::Main
>>

TypeName(typeName, isStruct) ::= <<
	<if(isStruct)>valuetype<endif> <typeName>
>>

Parameter(typeName, id) ::=<<
	<typeName> <id>
>>

LocalVar(typeName, id, isArray) ::= <<
	<typeName><if(isArray)>[]<endif> <id>
>>

BinaryOp(expressionOne, expressionTwo, op, requireNot) ::= <<
	<left>
	<right>
	<op>
	<if(requireNot)>not<endif>
>>

UnaryOp(expression, op) ::= <<
	<expression>
	<op>
>>


IfCmd(expression, code, Lzero)  ::= <<
	<expression>
	brfalse.s <LZero>
	<code; separator="\n">
<Lzero>:
>>

IfElse(condition, ifcode, elsecode, LZero, LOne)  ::= <<
	<condition>
	brfalse.s <LZero>
	<ifcode; separator="\n">
	br.s <LOne>
<LZero>:
	<elseCode; separator="\n">
<LOne>:
>>

While(condition, code, LZero, LOne)  ::= <<
<LZero>:
	<condition>
	brfalse.s <LOne>
	<statements; separator="\n">
	br.s <LZero>
<LOne>:
>>

Return(expression) ::= <<
	<expression; separator =";">
	ret
>>

MethodCall(methodType, methodName, parameterType, expression) ::= <<
	<expression; separator =";">
	call instance <methodType> Program::'<methodName>'(<parameterType; separator =",">)
>>

Expression(anythi) ::= <<
	<anythi; separator =";">
>>

LoadIntConstant(constant) ::= <<
	ldc.i4.<constant>
>>

Assignment(local, expression) ::= <<
	<expression>
	stloc.s <local>
>>

LoadParameter(parameter) ::= <<
	ldarg.s <parameter>
>>

Operation(op) ::= <<
	<op>
>>