		/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

group TAC;

Main(structDec, field, method) ::= <<

	.class Program
	{
		<structDec; separator="\n">
		<field; separator="\n">
		<mainMethod; separator="\n">
		<method; separator="\n">
	}
>>

StructDec(name, structDec, field) ::= <<
.public static class <name>
  {
	<structDec; separator="\n">
	<field; separator="\n">
  } // end of class <name>
>>

Field(typeName, id, isArray) ::= <<
	.field public <typeName><if(isArray)>[]<endif> <id>program
>>

Method(typeName, id, parameters, stackSize, localVar, statements) ::= <<
.method public <typeName> '<id>'(<parameters; separator=", ">)
  {
	.maxstack <stackSize>
	.locals init (
		<localVar; separator=", ">
	)
	<statements; separator="\n">
  } // end of method Program::'<id>'
  >>

MainMethod(stackSize, localVar, statements) ::= <<
	.method private static void
	Main(string[] y)
	{
		  .entrypoint
		  .maxstack <stackSize>
		  .locals (
			  <localVar; separator=", ">
		  )
		  <statements; separator="\n">

	} // end of method Program::Main
>>


TypeName(typeName, isStruct) ::= <<
	<if(isStruct)>valuetype<endif> <typeName>
>>

Parameter(typeName, id) ::=<<
	<typeName> <id>
>>

LocalVar(typeName, id, isArray) ::= <<
	<typeName><if(isArray)>[]<endif> <id>
>>

BinaryOp(expression1, expression2, op) ::= <<
	<expression1>
	<expression2>
	<op>
>>

Assignment(loadLocation, expression, storeLocation)  ::= <<
	<loadLocation>
	<expression>
	<storeLocation>
>>

IfCmd(expression, code, L0)  ::= <<
	<expression>
	brfalse.s <L0>
	<statements; separator="\n">
<L0>:
>>

IfElse(condition, ifcode, elsecode, t0, L0, t1, L1)  ::= <<
	<condition>
	brfalse.s <L0>
	<ifcode; separator="\n">
	br.s <L1>
<L0>:
	<elseCode; separator="\n">
<L1>:
>>

While(condition, code, L0, L1)  ::= <<
<L0>:
	<condition>
	brfalse.s <L1>
	<statements; separator="\n">
	br.s <L0>
<L1>:
>>

Return(expression) ::= <<
	<expression; separator =";">
	ret
>>

MethodCall(methodType, methodName, parameterType, expression) ::= <<
	<expression; separator =";">
	call instance <methodType> Program::'<methodName>'(<parameterType; separator =",">)
>>

VarDecl(id, type) ::= <<
	Load<type> <id>
>>

VarStructDecl(id, type) ::= <<
	LoadStruct <id>
	LoadStructName <type>
>>

ArrayDecl(varloading, position) ::= <<
{
	<varloading>
	LoadPosition <position>
}
>>