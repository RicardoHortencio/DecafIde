using Antlr4.StringTemplate;
using DecafIde.ILCode.ClassMembers.MethodMembers;
using DecafIde.ILCode.ClassMembers.MethodMembers.Statements;
using System.Collections.Generic;

namespace DecafIde.ILCode
{
    /// <summary>
    /// Main Command Class
    /// </summary>
    abstract class Command
    {
        private bool isSet = false;
        /// <summary>
        /// The templates file
        /// </summary>
        private TemplateGroup stg = new TemplateGroupFile(@"C:\Users\Paulo\SkyDrive\Visual Studio 2013\Projects\DecafIde\DecafIde\CIL.stg");
        /// <summary>
        /// The current template
        /// </summary>
        protected Template selfTemplate;

        /// <summary>
        /// Gets the current template name
        /// </summary>
        /// <returns>The current template name</returns>
        public abstract string getTemplateName();
        /// <summary>
        /// Initializes the current template code.
        /// </summary>
        public abstract void setGenCode();
        /// <summary>
        /// Gets an instance of the current template.
        /// </summary>
        /// <returns>An instance of the current template</returns>
        protected Template getSelfTemplate()
        {
            return stg.GetInstanceOf(getTemplateName());
        }
        /// <summary>
        /// Gets the inherited template name.
        /// By default it is the current template name in camelCase.
        /// </summary>
        /// <returns>The inherited template name</returns>
        public string getInheritedTemplateName()
        {
            string templateName = getTemplateName();
            return char.ToLower(templateName[0]) + templateName.Substring(1);
        }
        /// <summary>
        /// Returns a string with the code generated by the template.
        /// </summary>
        /// <returns>The code generated by the template</returns>
        public string getGenCode()
        {
            if (!isSet)
            {
                setGenCode();
                isSet = true;
            }
            return selfTemplate.Render();
        }
        /// <summary>
        /// Configures a command list as part of the current template.
        /// </summary>
        /// <param name="theCommandList">The Command List</param>
        public void setCommandList(IEnumerable<Command> theCommandList)
        {
            foreach (Command item in theCommandList)
                setSingleCommand(item);
        }
        /// <summary>
        /// Configures a single command as part of the current template.
        /// </summary>
        /// <param name="theCommandList">The Command List</param>
        public void setSingleCommand(Command theCommand)
        {
            setPlaceholder(theCommand.getInheritedTemplateName(), theCommand.getGenCode());
        }
        /// <summary>
        /// Configures the local variable list as part of the current template.
        /// </summary>
        /// <param name="theCommandList">The local variables list</param>
        public void setCommandList(IEnumerable<LocalVar> theCommandList)
        {
            int i = 0;
            foreach (LocalVar item in theCommandList)
            {
                i++;
                setSingleCommand(item, i);
            }
        }
        /// <summary>
        /// Configures a single local variable as part of the current template
        /// </summary>
        /// <param name="theCommand">The local variable</param>
        /// <param name="index">The local variable index</param>
        public void setSingleCommand(LocalVar theCommand, int index)
        {
            setPlaceholder(theCommand.getInheritedTemplateName(), "[" + index + "] " + theCommand.getGenCode());
        }
        /// <summary>
        /// Configures an expression's list as part of the current template
        /// </summary>
        /// <param name="fieldName">The current expression's list fieldName</param>
        /// <param name="theCommandList">The current expression's list</param>
        public void setCommandList(string fieldName, IEnumerable<ExpressionBaseClass> theCommandList)
        {
            foreach (ExpressionBaseClass item in theCommandList)
            {
                setSingleCommand(item);
            }
        }
        /// <summary>
        /// Configures a single expression as part of the current template
        /// </summary>
        /// <param name="fieldName">The current expression's fieldName</param>
        /// <param name="theCommand">The current expression</param>
        public void setSingleCommand(string fieldName, ExpressionBaseClass theCommand)
        {
            setPlaceholder(fieldName, theCommand.PushCode);
        }
        /// <summary>
        /// Sets a single placeholder with a given field name and value
        /// </summary>
        /// <param name="fieldName">The placeholder field name</param>
        /// <param name="fieldValue">The placeholder field value</param>
        public void setPlaceholder(string fieldName, string fieldValue)
        {
            selfTemplate.Add(fieldName, fieldValue);
        }
        /// <summary>
        /// Sets a single placeholder with a given field name and boolean value
        /// </summary>
        /// <param name="fieldName">The placeholder field name</param>
        /// <param name="fieldValue">The placeholder field boolean value</param>
        public void setPlaceholder(string fieldName, bool fieldValue)
        {
            selfTemplate.Add(fieldName, fieldValue ? "true" : "false");
        }

        public Command()
        {
            selfTemplate = getSelfTemplate();
        }
        public Command(string stgRoute)
        {
            stg = new TemplateGroupFile(stgRoute);
            selfTemplate = getSelfTemplate();
        }
    }
}
